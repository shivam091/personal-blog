import { LanguageLexers } from "./languages";
import { escapeHTML } from "./utils";

// Placeholder for Lexer to avoid circular dependency in modular view
class LexerFactory {
  // Constructor returns the specialized Lexer instance
  constructor(fileType) {
    const LexerClass = LanguageLexers[fileType] || LanguageLexers.js;
    return new LexerClass();
  }
}

export class BaseHighlighter {
  #lexer;

  constructor(fileType) {
    // The LexerFactory constructor returns the specialized Lexer instance
    this.#lexer = new LexerFactory(fileType);
  }

  /**
   * Main entry point to highlight a line.
   */
  highlightLine(line) {
    if (line.length === 0) return "<br>";
    return this.highlight(line);
  }

  /**
   * Abstract method: Must be implemented by subclasses to map tokens to CSS classes.
   */
  mapTokenTypeToClass(tokenType) {
    throw new Error("mapTokenTypeToClass must be implemented by subclass.");
  }

  /**
   * Renders the HTML based on tokens generated by the Lexer.
   */
  highlight(line) {
    const tokens = this.#lexer.tokenize(line);
    let htmlOutput = "";

    for (const token of tokens) {
      const className = this.mapTokenTypeToClass(token.type);

      // Preserve spaces and tabs visually *before* output
      const escapedValue = escapeHTML(token.value)
        .replace(/ /g, "<span class='space-char'> </span>")
        .replace(/\t/g, "<span class='tab-char'>\t</span>");

      if (className) {
        // Wrap the fully escaped content
        htmlOutput += `<span class="${className}">${escapedValue}</span>`;
      } else {
        // Plain text: already escaped
        htmlOutput += escapedValue;
      }
    }

    if (htmlOutput.length === 0) {
      return "<br>";
    }
    return htmlOutput;
  }
}